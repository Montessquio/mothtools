Options: Name Mangling, SET omission

/* Element Defs */
/* Aspect Defs */
<hidden?> aspect aspect.id {
	SET label = "Treasure"
	SET description = "This is something valuable."
	SET icon = "iconpath"
	SET verbicon = "iconpath"
	DECAY time decaycard? // Needs revision! //TODO
	SPAWN recipe chance? // "induces"
	XTRIGGER <ASPECT.XTRIGGERPARAMS>// Special Xtrigger for aspects
}

// Syntactic sugar for aspects:
// use ? to make hidden
// the arrow operator indicates what it might decay to
?aspect aspect.id "Label" ["Description"] -> time card {
	// other properties
} -> recipe chance? // induces sugar

/* Card Defs */
card card.id {
	SET label = "Treasure"
	SET description = "This is something valuable."
	SET icon = "iconpath"
	SET verbicon = "iconpath"
	SET resaturate [= <true|false>]?
	SET hidden [= <true|false>]? // set "isHidden", make card invisible when within a recipe
	SET unique [= <true|false>]?
	ASPECTS ( <ASPECT|CARD>,+ )
	UNIQUE <ASPECTID>? // if not specified, will set "unique" to true on self. Unique can be specified up to twice, once to specify self-uniqueness and once to specify a uniqueness group
	DECAY time decaycard? // LIFETIME + DECAY
	SPAWN recipe chance? // "induces"
	verbid -> <slotdef> + // can have more than one slot. Auto adds verb constraint
	XTRIGGER <CARD.XTRIGGERPARAMS> // Special Xtrigger for cards
}

// Syntactic Sugar for Cards
hidden card card.id "Label" ["Description"]( <ASPECTS>+ )? -> time card { 
	SET
	UNIQUE
	verbid -> <slotdef>
	XTRIGGER
} -> recipe chance? // induces sugar

?card card.id "Label" ["Description"]( <ASPECTS>+ )? -> time card { 
	SET
	UNIQUE
	verbid -> <slotdef>
	XTRIGGER
} => recipe chance? // induces Sugar

/* Deck Defs */
deck deck.id "Label" ["Description"]?{
	cards,+
	!cardid // the final card is implied to be the default, but can be specified using the ! marker.
}

mansus deck deck.id "Label" ["Description"]?{
	cardid "Message",+
	!cardid
}

/* Recipe Defs */
// Internal decks not allowed
// <CRAFT|HINT>? recipe <ASSOCIATED VERB> <RECIPE ID> ( <TABLE|EXTANT>? <REQUIREMENT: AMOUNT>,+ ) <MaxExecutions> {
// Shorthand for CRAFT=true is ! and shorthand for HINT=true is ?
craft recipe wih.reflect wih.determinehour ( wih.servicelantern.proto: 1 ) {
	/* Define Recipe Behavior */
	// Any key can be set, quotes on lhs are optional but mandatory on rhs
	SET label = "Remembrance"
	SET "startdescription" = "I will take stock of myself."
	SET description = "I have been a Name for a great deal of time, and have dutifully served an Hour."

	WARMUP 60

	SLOT slotdata 

	/* Modify sphere */

	// "effects" are done by specifying the target element.
	APPLY wih.servicelantern.proto -= 1

	// "mutations" are done by specifying a "sub-property" in an APPLY instruction
	APPLY wih.servicelantern.proto lantern += 1

	// "aspects" is invoked by using \local
	APPLY \local lantern += 1

	// Deck Effects
	DRAW wih.hours.lantern 1

	/* Game/Table Signals */

	SIGNAL signalimportantloop

	PURGE wih.servicelantern.proto

	BURN filename

	PORTAL portaleffect

	ENDING endingid <FLAVOUR>?

	// If no verbid is specified, defaults to self
	HALT verbid // End the verb, delete when user accepts. Think "spontaneous vitality" verb appearing.

	DELETE verbid // nuke from orbit. Nothing will remain

	// A pair of brackets opened immediately after close indicates creates an implicit,
	// unconditional link of last resort.
}
// inserting a "from" here will cause the implied next step to inherit from the previous,
// just like in a standalone def.
from? {
	/* Control Flow */
	// The side effects of calling an Alt recipe and a Link recipe
	// are different, so they are invoked separately.

	// LINK statements create links
	LINK recipeid
	LINK recipeid 50

	// GOTO statements generate alts
	GOTO recipeid 		// branch to recipe id after this one is done, "link" with 100% chance.
	GOTO recipeid 50 	// branch to recipe id after this one is done, "link" with 50% chance

	// Branch to a recipe if the conditions are met (inclusive). Accepts the same list items as function args above.
	// If the matching recipeid is defined and has the same requirements, then that recipe is linked.
	// If the matching recipeid is undefined or is defined but has different requirements, the recipe will be monomporphically generated.
	GOTO recipeid if ( items... )
	LINK recipeid if ( items... )

	// Monomorphization can be combined with chance percentages
	GOTO recipeid if 50 ( items... )
	LINK recipeid if 50 ( items... )

	// ... as well as challenges
	GOTO recipeid if ( items... ) {
		"basic" <DefKey>
		"advanced" <DefKey>
	}

	// challenges have shorthand, too 
	GOTO recipeid if ( items... ) {
		!<DefKey> // Advanced
		<DefKey> // Implied Basic
	}

	// The following can only be applied to GOTO statements.

	// Alt recipe that creates a new situation. Adds the "additional" flag.
	// If the linked recipe does not have a different verb type,
	GOTO recipeid -> SPAWN
	GOTO recipeid if ( items... ) -> SPAWN
	GOTO recipeid if 50 ( items... ) -> SPAWN
	GOTO recipeid if ( items... ) -> SPAWN

	// Instead of SPAWN, EXPEL can be specified.
	// This makes the verb emit grabbed cards
	// to a spawned recipe.
	// An EXPEL with either no or an empty expel def
	// Desugars to a SPAWN
	// Implies SPAWN
	GOTO recipeid -> EXPEL { <QuantityDefKey>* }
	GOTO recipeid if ( items... ) -> EXPEL
	GOTO recipeid if 50 ( items... ) -> EXPEL
	GOTO recipeid if ( items... ) -> EXPEL
}

// this can go on indefinitely.

/* Verb Defs */

// The default verb type is "Permanent"
verb verbid "Label" ["Description"] 
// Prepend a verb with temp or ? to make it temporary
temp verb verbid  "Label" ["Description"] 
?verb verbid  "Label" ["Description"] 
// A slot can be added to a verb
verb verbid "Label" ["Description"] ( <SLOTPARAMS> )


/* Slot Defs */
// Slots defined in a Recipe or Verb manifest as QuickTime events
// Slots defined in a Card manifest as verb-specific slots. See Card slot spec.

slot slotid "Label" ["Description"] ( <REQUIREMENTS|!FORBIDDEN>+ )?

consume slot slotid "Label" ["Description"] ( <REQUIREMENTS|!FORBIDDEN>+ )?
// BANG means consume
!slot slotid "Label" ["Description"] ( <REQUIREMENTS|!FORBIDDEN>+ )?

// QUESTION means greedy
greedy slot slotid "Label" ["Description"] ( <REQUIREMENTS|!FORBIDDEN>+ )?
?slot slotid "Label" ["Description"] ( <REQUIREMENTS|!FORBIDDEN>+)?

// Combinations allowed
consume greedy slot slotid "Label" ["Description"] ( <REQUIREMENTS|!FORBIDDEN>+)?
greedy consume slot slotid "Label" ["Description"] ( <REQUIREMENTS|!FORBIDDEN>+)?
!?slot slotid "Label" ["Description"] ( <REQUIREMENTS|!FORBIDDEN>+)?
?!slot slotid "Label" ["Description"] ( <REQUIREMENTS|!FORBIDDEN>+)?

/* FROM syntax */
// The following syntax will cause ALL undefined values from the current
// component to be inherited from the parent component.
from item.baseid <ComponentDef> .. 

/* Legacy Defs */
// Legacies will remain defined in JSON/HJSON

/* Ending Defs */
// Endings will remain defined in JSON/HJSON